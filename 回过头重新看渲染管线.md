## 定义

渲染**管线**是 OpenGL 在渲染对象时采取的步骤序列，也就是计算机图形系统将三维模型[渲染](https://zh.wikipedia.org/wiki/%E6%B8%B2%E6%9F%93 "渲染")到二维屏幕上的过程。

搬运下wiki上的管线图片

![图片](static/RenderingPipeline.png)
## Vertex Specification 顶点规范

渲染管线的第一个阶段，顶点规范是指为了使用特定的着色器程序进行渲染，而设置所需的对象以及使用这些对象进行渲染的过程。对象包括顶点数组对象、缓冲对象、顶点属性等，它们定义了顶点数据的来源和格式。顶点规范是渲染管线中的第一个阶段，它决定了后续阶段如何处理顶点数据。

### Vertex Stream 顶点流

要想进行渲染，你必须使用一个包含顶点着色器的着色器程序或程序管线。顶点着色器的用户自定义输入变量定义了该着色器所期望的顶点属性列表，其中每个属性都映射到一个用户自定义输入变量。这组属性定义了顶点流必须提供哪些值才能正确地渲染。

比如以下着色器
```glsl

attribute vec3 position;

void main() {
  // .....
}
```

这个顶点着色器自定义了预期期望的顶点属性position, 那么顶点流必须提供这个值才能正确渲染。

顶点流中的顶点顺序非常重要: 

这个顺序决定了OpenGL如何处理和渲染由顶点流生成的图元。有两种方式可以用顶点数组进行渲染。

- 你可以按照数组的顺序生成一个流，

- 或者你可以使用一个索引列表来定义顺序。索引控制接收顶点的顺序，而且索引可以多次指定同一个数组元素。

假设你有一个包含三个顶点的三维位置数据的数组，如下所示：
```js
{ {1, 1, 1}, {0, 0, 0}, {0, 0, 1} }
```

Opengl将会按照顺序接受和处理这三个顶点，但是也可以指定另外一个索引列表，该列表将会指定索引的顶点及顺序

假设我们有以下索引列表：
```js
{2, 1, 0, 2, 1, 2}
```

如果我们使用上面的属性数组渲染，但由索引列表选择，OpenGL 将收到以下顶点属性数据流：
```js
{ {0, 0, 1}, {0, 0, 0}, {1, 1, 1}, {0, 0, 1}, {0, 0, 0}, {0, 0, 1} }
```

### Primitives 图元

上面的流还不足以绘制任何东西；你还必须告诉OpenGL如何解释这个流。这意味着你要告诉OpenGL用什么样的图元来解释这个流。

可以是三角形、点或线，具体来说，线也可以是直线或者是线段，三角形既可以是首尾相连的也可以是扇形向量的

### Primitive的含义

在OpenGL中，Primitive这个术语用来指代两个相似但不同的概念。第一个意思是指OpenGL用来确定一组顶点在渲染时代表什么的解释方式，比如“GL_POINTS”, 这就是在顶点流中的解释含义。

另一个意思是指作为**Primitive Assembly**部分的一组顶点的解释结果，也称为“**base primitive（ 基元 ）**”。

**Primitive Assembly**作为渲染管线的第六个阶段，暂时按下不表

## Vertex Processing 顶点处理

顶点处理阶段几乎都是可编程的操作。这允许用户代码自定义顶点的处理方式。每个阶段代表一种不同的着色器操作。

主要有三种着色器在此阶段可用，**Vertex Shader 顶点着色器**，**Tessellation Shader 曲面细分着色器**，**Geometry Shader 几何着色器**

### Vertex Shader顶点着色器

负责处理单个顶点的处理。顶点着色器接收顶点属性数据，这些数据是由绘制命令从顶点数组对象中指定的。顶点着色器从顶点流中接收一个顶点，并生成一个顶点到输出顶点流。输入顶点和输出顶点之间必须有一个1:1的映射。

最老实的着色器，同时也是最普遍的着色器， 输入和输出是一一对应的。

### Tessellation Shader 曲面细分着色器

opengl4.0新特性

曲面细分是OpenGL渲染管线中的顶点处理阶段，它把一块顶点数据细分成更小的图元。这个过程由两个着色器阶段和一个固定函数阶段控制。

一般来说，曲面细分的过程涉及到把一种类型的块细分，然后为每个生成的顶点计算新的顶点值（位置、颜色、纹理坐标等）。曲面细分管线的每个阶段执行这个过程的一部分。

曲面细分控制着色器（TCS）决定要做多少曲面细分（它也可以调整实际的块数据，以及向后面的阶段提供额外的块数据）。因此，TCS主要负责保证块之间的连续性。所以如果你有两个相邻的块需要有不同的曲面细分水平，那么不同块的TCS调用需要使用它们的曲面细分控制来保证块之间共享的边使用相同的曲面细分水平。如果没有这种保护，本应连续的块之间就会出现缝隙和断裂。

TCS是可选的；如果没有提供TCS，可以使用默认的曲面细分值。

曲面细分图元生成器把输入块根据TCS计算出来或者默认提供的值进行细分。

曲面细分评估着色器（TES）接收细分后的块，并为每个生成的顶点计算顶点值

聊聊曲面细分着色器的应用场景：

一个篮球，当相机距离够近时，为了更真实，篮球的凹凸特性要通过顶点着色器实现的话，需要很多的顶点，这无疑是很废性能的一件事，曲面细分着色器则能做到这一点。

简单说：曲面细分着色器可以不断细分一个几何体 将它变成球体，也可以不断细分一条直线 将它变成曲线。通过比较调整相机的距离，可以动态调控细分值，来达到真实和性能的平衡。

### Geometry Shader 几何着色器

几何着色器调用以一个图元作为输入，并可能输出零个或多个图元。对于单个几何着色器调用能够生成多少个图元有实现定义的限制。几何着色器被编写为接受特定的输入图元类型并输出特定的图元类型。

几何着色器可以对顶点进行无中生有的操作，当然也能实现曲面细分的功能，但是这不是设计此着色器的初衷，几何着色器的主要用处在于：

- 分层渲染
	把一个图元渲染到多个图像上，而不需要改变绑定的渲染目标。延迟着色渲染时通常需要用到一个叫G-buffer的缓存技术，分层渲染能更好的完成这一步骤，性能上更优秀，因为只需要调用一次着色器
- 变换反馈
	主要用于将CPU中的计算部分转移至GPU中实现




