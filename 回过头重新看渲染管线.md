## 定义

渲染**管线**是 OpenGL 在渲染对象时采取的步骤序列，也就是计算机图形系统将三维模型[渲染](https://zh.wikipedia.org/wiki/%E6%B8%B2%E6%9F%93 "渲染")到二维屏幕上的过程。

搬运下opengl-wiki上的渲染管线图片

![图片](static/RenderingPipeline.png)
## Vertex Specification 顶点规范

渲染管线的第一个阶段，顶点规范是指为了使用特定的着色器程序进行渲染，而设置所需的对象以及使用这些对象进行渲染的过程。对象包括顶点数组对象、缓冲对象、顶点属性等，它们定义了顶点数据的来源和格式。顶点规范是渲染管线中的第一个阶段，它决定了后续阶段如何处理顶点数据。

### Vertex Stream 顶点流

要想进行渲染，你必须使用一个包含顶点着色器的着色器程序或程序管线。顶点着色器的用户自定义输入变量定义了该着色器所期望的顶点属性列表，其中每个属性都映射到一个用户自定义输入变量。这组属性定义了顶点流必须提供哪些值才能正确地渲染。

比如以下着色器
```glsl

attribute vec3 position;

void main() {
  // .....
}
```

这个顶点着色器自定义了预期期望的顶点属性position, 那么顶点流必须提供这个值才能正确渲染。

顶点流中的顶点顺序非常重要: 

这个顺序决定了OpenGL如何处理和渲染由顶点流生成的图元。有两种方式可以用顶点数组进行渲染。

- 你可以按照数组的顺序生成一个流，

- 或者你可以使用一个索引列表来定义顺序。索引控制接收顶点的顺序，而且索引可以多次指定同一个数组元素。

假设你有一个包含三个顶点的三维位置数据的数组，如下所示：
```js
{ {1, 1, 1}, {0, 0, 0}, {0, 0, 1} }
```

Opengl将会按照顺序接受和处理这三个顶点，但是也可以指定另外一个索引列表，该列表将会指定索引的顶点及顺序

假设我们有以下索引列表：
```js
{2, 1, 0, 2, 1, 2}
```

如果我们使用上面的属性数组渲染，但由索引列表选择，OpenGL 将收到以下顶点属性数据流：
```js
{ {0, 0, 1}, {0, 0, 0}, {1, 1, 1}, {0, 0, 1}, {0, 0, 0}, {0, 0, 1} }
```

### Primitives 图元

上面的流还不足以绘制任何东西；你还必须告诉OpenGL如何解释这个流。这意味着你要告诉OpenGL用什么样的图元来解释这个流。

可以是三角形、点或线，具体来说，线也可以是直线或者是线段，三角形既可以是首尾相连的也可以是扇形向量的

### Primitive的含义

在OpenGL中，Primitive这个术语用来指代两个相似但不同的概念。第一个意思是指OpenGL用来确定一组顶点在渲染时代表什么的解释方式，比如“GL_POINTS”, 这就是在顶点流中的解释含义。

另一个意思是指作为**Primitive Assembly**部分的一组顶点的解释结果，也称为“**base primitive（ 基元 ）**”。

**Primitive Assembly**作为渲染管线的第六个阶段，暂时按下不表

## Vertex Processing 顶点处理

顶点处理阶段几乎都是可编程的操作。这允许用户代码自定义顶点的处理方式。每个阶段代表一种不同的着色器操作。

主要有三种着色器在此阶段可用，**Vertex Shader 顶点着色器**，**Tessellation Shader 曲面细分着色器**，**Geometry Shader 几何着色器**

### Vertex Shader顶点着色器

负责处理单个顶点的处理。顶点着色器接收顶点属性数据，这些数据是由绘制命令从顶点数组对象中指定的。顶点着色器从顶点流中接收一个顶点，并生成一个顶点到输出顶点流。输入顶点和输出顶点之间必须有一个1:1的映射。

最老实的着色器，同时也是最普遍的着色器， 输入和输出是一一对应的。

### Tessellation Shader 曲面细分着色器

opengl4.0新特性

曲面细分是OpenGL渲染管线中的顶点处理阶段，它把一块顶点数据细分成更小的图元。这个过程由两个着色器阶段和一个固定函数阶段控制。

一般来说，曲面细分的过程涉及到把一种类型的块细分，然后为每个生成的顶点计算新的顶点值（位置、颜色、纹理坐标等）。曲面细分管线的每个阶段执行这个过程的一部分。

曲面细分控制着色器（TCS）决定要做多少曲面细分（它也可以调整实际的块数据，以及向后面的阶段提供额外的块数据）。因此，TCS主要负责保证块之间的连续性。所以如果你有两个相邻的块需要有不同的曲面细分水平，那么不同块的TCS调用需要使用它们的曲面细分控制来保证块之间共享的边使用相同的曲面细分水平。如果没有这种保护，本应连续的块之间就会出现缝隙和断裂。

TCS是可选的；如果没有提供TCS，可以使用默认的曲面细分值。

曲面细分图元生成器把输入块根据TCS计算出来或者默认提供的值进行细分。

曲面细分评估着色器（TES）接收细分后的块，并为每个生成的顶点计算顶点值

聊聊曲面细分着色器的应用场景：

一个篮球，当相机距离够近时，为了更真实，篮球的凹凸特性要通过顶点着色器实现的话，需要很多的顶点，这无疑是很废性能的一件事，曲面细分着色器则能做到这一点。

简单说：曲面细分着色器可以不断细分一个几何体 将它变成球体，也可以不断细分一条直线 将它变成曲线。通过比较调整相机的距离，可以动态调控细分值，来达到真实和性能的平衡。

### Geometry Shader 几何着色器

几何着色器调用以一个图元作为输入，并可能输出零个或多个图元。对于单个几何着色器调用能够生成多少个图元有实现定义的限制。几何着色器被编写为接受特定的输入图元类型并输出特定的图元类型。

几何着色器可以对顶点进行无中生有的操作，当然也能实现曲面细分的功能，但是这不是设计此着色器的初衷，几何着色器的主要用处在于：

- 分层渲染
	把一个图元渲染到多个图像上，而不需要改变绑定的渲染目标。延迟着色渲染时通常需要用到一个叫G-buffer的缓存技术，分层渲染能更好的完成这一步骤，性能上更优秀，因为只需要调用一次着色器
- 变换反馈
	主要用于将CPU中的计算部分转移至GPU中实现


## Vertex Post-processing 顶点后处理阶段

### Transform Feedback 变换反馈

变换反馈是 OpenGL 渲染管线中的一个阶段，它可以将顶点处理阶段的输出值记录到缓冲对象中。只有最后一个顶点处理阶段可以执行变换反馈。

### Primitive Assembly 图元装配

图元装配是将顶点流转换为一系列图元的过程，根据渲染命令中指定的图元类型进行转换。在这一点上，图元也可以被丢弃，以便在不渲染任何内容的情况下进行变换反馈。

这个阶段是将顶点流转换为一系列基本图元的过程，比如点、线或三角形。这些图元会根据渲染命令指定的图元类型进行分解和组合，然后传递给光栅化阶段进行渲染。这个阶段可能会在顶点处理之后或者几何着色器之前发生，具体取决于渲染管线的设置。

### Clipping 裁剪

这个阶段是将图元裁剪到视景体内的过程，视景体是由gl_Position输出定义的一个立方体，任何在立方体外的图元都会被丢弃或者切割。裁剪可以通过深度限制和用户定义的裁剪平面来修改。裁剪后的图元会被转换为归一化设备坐标，并传递给视口变换阶段


#### 用户定义裁剪平面

如果使用着色器，可以通过输出数组gl_ClipDistance来设置用户定义的裁剪平面。每个数组元素代表一个裁剪条件，如果元素的值为非负数，则表示图元在该裁剪区域内，否则表示在外部。需要先重新声明这个数组并指定大小，然后还要通过glEnable来激活对应的裁剪距离。

以下是一个示例代码演示这个过程：
```c++
// 定义一个裁剪平面的方程式，形式为Ax + By + Cz + D = 0 
// 这里的平面是垂直于y轴，距离原点10个单位
double[] planeEquation = {0.0, 1.0, 0.0, -10.0};

// 设置裁剪平面的索引为GL_CLIP_PLANE0 
int planeIndex = GL11.GL_CLIP_PLANE0;

// 使用glClipPlane函数将方程式传递给OpenGL 
// 需要将方程式转换为DoubleBuffer类型 
DoubleBuffer planeBuffer = BufferUtils.createDoubleBuffer(4); planeBuffer.put(planeEquation); planeBuffer.flip(); GL11.glClipPlane(planeIndex, planeBuffer);

// 使用glEnable函数开启裁剪平面的效果 
GL11.glEnable(planeIndex);

// 渲染场景，任何在裁剪平面外的图元都会被丢弃或切割 
renderScene();

// 使用glDisable函数关闭裁剪平面的效果
GL11.glDisable(planeIndex);
```

如果想用着色器实现，可以用如下步骤：
```glsl
// 在着色器中重新声明gl_ClipDistance数组，指定大小为1
out gl_PerVertex { vec4 gl_Position; float gl_ClipDistance[1]; };

// 定义一个裁剪平面的方程式，形式为Ax + By + Cz + D = 0 
// 这里的平面是垂直于y轴，距离原点10个单位 
vec4 planeEquation = vec4(0.0, 1.0, 0.0, -10.0);

// 计算顶点位置与裁剪平面的距离，存储在gl_ClipDistance[0]中 
gl_ClipDistance[0] = dot(gl_Position, planeEquation);

// 在OpenGL中激活GL_CLIP_DISTANCE0 
GL11.glEnable(GL11.GL_CLIP_DISTANCE0);

// 渲染场景，任何在裁剪平面外的图元都会被丢弃或切割 
renderScene();

// 关闭GL_CLIP_DISTANCE0 
GL11.glDisable(GL11.GL_CLIP_DISTANCE0);
```

#### 深度裁剪

## Rasterization 光栅化

光栅化阶段是将屏幕空间的图元（如三角形）分解为离散的像素，并对每个像素进行插值和着色的过程。这个阶段会计算每个像素的颜色、深度、纹理坐标等属性，并将它们传递给片段着色器。光栅化阶段还会执行一些测试，如深度测试、模板测试、裁剪测试等，来决定哪些像素最终会被渲染到屏幕上。

## Fragment Shader 片段着色器

片段着色器是OpenGL管线中在图元被光栅化后处理每个像素的可编程阶段。

它接收上一个顶点处理阶段插值得到的输出变量（如颜色、深度、纹理坐标等），并计算最终的颜色和深度值。片段着色器可以使用discard命令来丢弃某些像素，或者使用gl_FragDepth来修改像素的深度值。片段着色器还可以使用一些内置的输入变量，如gl_FragCoord, gl_FrontFacing, gl_PointCoord等，以及一些内置的或自定义的输出变量，如gl_FragColor, gl_FragData, gl_SampleMask等。

## Per-Sample Processing 逐像素处理

Per-Sample Processing是OpenGL渲染管线中的一个阶段，它处理片段着色器输出的每个像素，并将它们写入不同的缓冲区。这个阶段包括以下几个操作：

- Pixel ownership test: 检查像素是否属于OpenGL，如果不属于则丢弃。
- Scissor test: 检查像素是否在指定的矩形区域内，如果不在则丢弃。
- Stencil test: 检查像素的模板值是否满足指定的条件，如果不满足则丢弃或修改。
- Depth test: 检查像素的深度值是否满足指定的条件，如果不满足则丢弃或修改。
- Occlusion query: 如果像素通过了深度测试，则增加一个计数器或设置一个布尔值，用于统计或判断是否有像素被渲染。
- Blending: 如果启用了混合功能，则将像素的颜色与帧缓冲中对应位置的颜色进行混合运算，得到最终的颜色值。
- SRGB conversion: 如果启用了sRGB功能，则将像素的颜色从线性空间转换为sRGB空间，或者反之。
- Dithering: 如果启用了抖动功能，则根据像素的位置和颜色值进行一些随机或规律的扰动，以减少颜色分辨率造成的条纹现象。
- Logical operation: 如果启用了逻辑操作功能，则将像素的颜色与帧缓冲中对应位置的颜色进行逻辑运算，得到最终的颜色值。
- Write mask: 根据指定的掩码，决定是否写入像素的颜色、深度和模板值到相应的缓冲区。