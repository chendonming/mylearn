# DP 动态规划

先来个基础的讲解
A: 1+1+1 等于多少
B: 3
A: 1 + 1 + 1 + 1 等于多少
B: 4

请问 1+1+1+1 怎么计算会比较快？当然是直接复用之前的结果 3 啦，之前的结果和现在要求的结果有什么关系？是这样的关系：之前的结果+1=现在的结果。用关系式表达就是:

```
dp[n] = dp[n-1] + 1
```

哈哈，我们得到使用动态规划算法的一般步骤了：

- 定义式子含义
  我定义为 dp[n], 其中 n 代表第几次的结果。dp[2]代表第 2 次
- 找到关系式
  我们发现第 n 次的结果是前一次的结果+1，有这样的关系式 dp[n] = dp[n-1]+1
- 找到初始值
  我们发现没有具体的值，我们是无法开始计算的，所以直接逆推找到初始值，dp[0] = 1

这只是一般的比较简单的动态规划，实际情况会很复杂，接下来看几个经典算法题

## 青蛙跳台阶（ 一维 DP ）

DP 就是动态规划的简称，青蛙跳台阶只需要考虑多少次到达这一个条件，所以称之为一维 DP。题目为：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

```js
function frogJumpingSteps(n) {
  // 假设跳到了第n级台阶，青蛙可能是第n-1级上来的，也可能是n-2级上来的
  // 一直逆推，归纳出以下关系式
  // dp[n] = dp[n-1]+dp[n-2]
  // 当n=3时 dp[3] = dp[2] + dp[1]
  // 初始值dp[0]=0 dp[1]=1 dp[2] = 2

  var dp = new Array(n + 1);
  dp[0] = 0;
  dp[1] = 1;
  dp[2] = 2;
  for (var i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(frogJumpingSteps(5));
```

## 背包问题

### 0/1 背包问题

给定 n 种物品和一背包。物品 i 的重量为 wi，其价值为 vi，背包的容量为 c。问应该如何选择装入背包中的物品，使得装入背包中物品的总价值最大？

- 确定目标
  我们得找个目标，ok 目标是价值。那么价值和什么有关？和你是第几次拿物品还有你拿物品时你的背包容量的大小有关系。我们于是有个结果表达 dp[i][j], 我们定义 i 代表是第几次拿物品，j 代表拿物品时的容量大小。
- 找状态/关系式
  仔细想想，决定你本次拿取的价值是什么？拿还是不拿，如果不拿本次的价值就等于上一次拿物品的价值，拿的话，看本次物品的重量和背包剩余重量判断，容量足够的话，本次价值就等于上一次拿物品的价值+本次物品的价值，容量不行的话，还是等于上一次物品的价值,看图：
  ![](static/dp草图.drawio.png)

- 初始值
  很容易知道当 i 或者 j 为 0 时，dp[i][j]=0

以下是 JavaScript 解决方案

```js
function knapsack(wi, vi, c) {
  var dp = create2DArray(wi.length + 1, c + 1, 0)
  var len = wi.length

  // 行： 物品编号
  for (let i = 0; i <= len; i++) {
    //列 还剩余的背包容量
    for (let j = c; j >= 0; j--) {
      if (i === 0 || j === 0) {
        dp[i][j] = 0
        continue
      }

      if (j >= wi[i]) {
        // 剩余容量大于当前背包容量
        dp[i][j] = Math.max(dp[i - 1][j - wi[i]] + vi[i], dp[i - 1][j])
      } else {
        dp[i][j] = dp[i - 1][j]
      }
    }
  }

  return dp[len][c]

```

时间复杂度为 O(m\*n) m 为物品数量, n 为背包容量

### 完全背包问题

只是背包的变种而已，对于 0/1 背包，其中的物品变为无限供应，题目改为给定 n 种物品和一背包。物品 i 的重量为 wi，背包的容量为 c。物品数量无限供应。 问：有多少种方法可以使背包恰好装满。

其实通过上面的代码后，我们大概知道了 DP 规划问题的套路了，我们必须找到【状态】【抉择】，以及当前的抉择和上一次的抉择之间的关系，伪代码如下：

```
for ... [状态1]
  for .... [状态2]
     if()
       ....【抉择】
       dp[i][j]=xxxxxxx
```

### 多重背包问题

# 滑动窗口

# 二分查找
