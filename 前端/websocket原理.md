对于处理“推送”场景，存在轮询、长轮询、websocket等方式，在了解websocket原理之前，首先了解下以前是如何解决“推送”这个需求的。

# HTTP协议

首先，在websocket协议推出之前，客户端和服务端的通信方式一般为http协议。

- http协议构建于TCP/IP协议之上的，属于应用层协议。
- 无连接。客户端和服务器之间的HTTP连接是一次性的，每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求再重新建立连接。
- 无状态。服务器对于客户端的请求处理没有记忆能力，服务器不知道客户端的状态。也就是说，每个请求都是独立的，服务器不会根据前面的请求来影响后面的请求。

当系统复杂后，http协议便会暴露出它的缺点，比如：无连接，频繁访问多个资源的时候，需要不断实行建立链接、销毁链接，这会降低网络效率。于是，http1.1提出了keep-alive方案，允许复用连接，减少了建立连接销毁连接的损耗。当然了keep-alive不是万能的，必须合理设置timeout时间，因为keep-alive保持连接时，服务端资源是不会释放的。

keep-alive被称为持久链接/长链接，和http1.0的短链接相对应。

无状态是http协议的另一个显著特征。缺点在于如果后续处理需要前面的信息，就必须重传，这样可能导致数据传输量增大。为了解决这个问题，出现了两种用于保持连接状态的技术，**Cookie**和**Session**。

Cookie是服务器发送给客户端的一些特殊信息，存放在客户端的存储中，客户端每次向服务器发送请求时都会带上这些信息。

Session是服务器为客户端开辟的一些存储空间，保存在服务器上，同时将标识Session的SessionId传递给客户端，客户端每次请求时都会带上这个SessionId

# 轮询（ Polling ）

理解完HTTP协议，我们大概可以想象出最简单的“推送”方案了。
轮询（Polling）就是由客户端每隔一段时间去请求服务端信息，直到从服务端取到新的信息，这就是一个不断询问的方式。

轮询的优点是简单。缺点如下：
- 服务端需要更快的处理速度，因为客户端会不断的发送请求
- 浪费系统资源，因为大部分请求都是无效请求，只有信息更新的那一刻属于有效请求。
- 轮询不能保证实时性，因为可能信息更新发生在两次轮询之间。

# 长轮询（ Long Polling ）

长轮询为了解决轮询中2和3的问题，即大量无效请求和不能保证实时性的问题。

长轮询的大致流程如下：
客户端发送一个请求，服务端直接挂起请求，在对应数据得到之后，再进行响应，客户端得到响应。

类比一下日常生活就是打电话，客户端打电话到服务端：
客户端：帮我找份数据
服务端：好嘞，等下啊
。。。这段时间服务端没有挂断电话。。。
。。。服务端找到数据后。。。。
服务端：找到了，数据是xxxxxx
客户端：收到！

这只是一个客户的情况，成千上万个客户呢？这时候服务端需要的就不是更快的处理速度了，而是更多的电话！so\~\~，这就是长轮询的缺点。

长轮询的缺点在于，服务器必须能够处理许多挂起的连接。某些服务器架构是每个连接对应一个进程，导致进程数和连接数一样多，而每个进程都会消耗相当多的内存。因此，过多的连接会消耗掉全部内存。

# WebSocket协议

 WebSocket 协议提供了一种**全双工**的通信机制, 服务端可以主动向客户端推送数据, WebSocket 协议采用了 HTTP 协议来握手, 与 HTTP 使用相同的默认端口, 这一切都是为了兼容现有的 HTTP 组件或代理, 但 WebSocket 与 HTTP 是相互独立的协议, 二者并不存在上下的层级关系

